import requests
import json
import base64
import random
import string
import boto3
import time
import os

# chinook repo id
gitlab_repo_id = os.getenv('GITLAB_REPO_ID')

# Gitlab User Id
gitlab_user_id = os.getenv('GITLAB_USER_ID')

# headers for Gitlab API
gitlab_headers = {
    'Content-Type': 'application/json',
    'PRIVATE-TOKEN': os.getenv('GITLABTOKEN'),
}

slack_headers = {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer ' + os.getenv('SLACKMETABASETOKEN'),
}

# Pulumi will pass the DynamoDB Table as an environment variable when creating the Lambda Function
dynamodb_table_name = os.getenv('DYNAMODBTABLENAME')

# Reference for the DynamoDB Table
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(dynamodb_table_name)

# Generate a new branch and PR in Gitlab
def new_branch(id, file, new_content, gitlab_action, assignee_id, name):

    # generate random string for branch name
    res = ''.join(random.choices(string.ascii_lowercase + string.digits, k=16))

    branch_name = 'metabaseversion' + res

    branch_payload = {
        'branch': branch_name,
        'ref': 'main'
    }

    # POST a new branch from main
    branch_response = requests.post(
        f'https://gitlab.com/api/v4/projects/{gitlab_repo_id}/repository/branches',
        headers=gitlab_headers,
        json=branch_payload
    )

    # Payload for a new commit replacing the repo query content with the updated Metabase content
    commit_payload = {
        'branch': branch_name,
        'commit_message': f'Update version for Metabase query {file}',
        'actions': [
            {
                'action': gitlab_action,
                'file_path': f'mb/queries/{file}',
                'content': new_content
            }
        ]
    }

    # POST for the new commit
    commit_response = requests.post(
        f'https://gitlab.com/api/v4/projects/{gitlab_repo_id}/repository/commits',
        headers=gitlab_headers,
        json=commit_payload
    )

    title = 'Autogenerated Metabase Update to Query ' + str(id) + ': ' + name

    pr_payload = {
        'source_branch': branch_name,
        'target_branch': 'main',
        'title': title,
        'assignee_id': gitlab_user_id,
        'reviewer_ids': [gitlab_user_id],
        'remove_source_branch': True,
        'squash': True
    }

    # POST the new PR
    pr_response = requests.post(
        f'https://gitlab.com/api/v4/projects/{gitlab_repo_id}/merge_requests',
        headers=gitlab_headers,
        json=pr_payload
    )

    pr_dict = json.loads(pr_response.text)
    pr_iid = pr_dict['iid']

    # Post the PR URL and Title to Slack
    slack_message = '{}, `{}`'.format(pr_dict['web_url'], pr_dict['title'])

    slack_payload = {
        'channel': os.getenv('MB_SLACK_CHANNEL'),
        'text': slack_message,
    }

    response = requests.post(
        'https://slack.com/api/chat.postMessage',
        headers=slack_headers,
        json=slack_payload
    )

    return branch_name, pr_iid

# Update an existing PR in Gitlab
def update_branch(file, new_content, gitlab_action, current_branch):

    # Payload for a new commit replacing the repo query content with the updated Metabase content
    commit_payload = {
        'branch': current_branch,
        'commit_message': f'Update version for Metabase query {file}',
        'actions': [
            {
                'action': gitlab_action,
                'file_path': f'mb/queries/{file}',
                'content': new_content
            }
        ]
    }

    # POST for the new commit
    commit_response = requests.post(
        f'https://gitlab.com/api/v4/projects/{gitlab_repo_id}/repository/commits',
        headers=gitlab_headers,
        json=commit_payload
    )

    return current_branch


# Close PR
def close_pr(iid):
    close_pr_update = {
        'state_event': 'close'
    }
    close_pr_response = requests.put(
        f'https://gitlab.com/api/v4/projects/{gitlab_repo_id}/merge_requests/{iid}',
        headers=gitlab_headers,
        json=close_pr_update
    )


# Update DynamoDB
def update_dynamodb_item(branch, iid, query_id, revert_at=None):

    # Add branch, iid, and revert_at from DynamoDB
    dynamo_str = 'SET branch=:Branch, iid=:Iid'
    dynamo_exp = {
        ':Branch': branch,
        ':Iid': iid,
    }

    if revert_at is not None:
        dynamo_str += ', revert_at=:Revert_at'
        dynamo_exp[':Revert_at'] = revert_at

    table.update_item(
        Key={'query_id': query_id},
        UpdateExpression=dynamo_str,
        ExpressionAttributeValues=dynamo_exp,
    )

# Remove DynamoDB item
def remove_dynamodb_item(query_id, include_revert=False):

    dynamo_str = 'REMOVE branch, iid'
    if include_revert:
        dynamo_str += ', revert_at'

    table.update_item(
        Key={'query_id': query_id},
        UpdateExpression=dynamo_str,
    )



def handler(event, context):

    # The URL your organization uses for Metabase; e.g. "https://example.metabaseapp.com"
    mb_url = os.getenv('MB_URL')

    # headers for Metabase API
    mb_headers = {
        'Content-Type': 'application/json',
        'X-Metabase-Session': os.getenv('MB_SESSION'),
    }

    # GET all the Metabase Query Content
    search_tags_response = requests.get(
        f'{mb_url}/api/card/',
        headers=mb_headers,
    )

    # Metabase will automatically log every user out after two weeks. If the session has expired, we will need a new one
    if search_tags_response.status_code == 401:

        metabase_login = {
            'username': os.getenv('MB_LOGIN_USERNAME'),
            'password': os.getenv('MB_LOGIN_PASSWORD'),
        }

        metabase_login_headers = {
            'Content-Type': 'application/json',
        }

        metabase_login_response = requests.post(
            f'{mb_url}/api/session/',
            headers=metabase_login_headers,
            json=metabase_login
        )

        metabase_login_dict = json.loads(metabase_login_response.text)
        session_id = metabase_login_dict['id']

        mb_headers['X-Metabase-Session'] = session_id

        # Initialize a client to update lambda with the new session ID
        client = boto3.client('lambda')

        lambda_response = client.update_function_configuration(
            FunctionName='metabase-version-lambda',
            Environment={
                'Variables': {
                    'MB_SESSION': session_id,
                    'DYNAMODBTABLENAME': os.getenv('DYNAMODBTABLENAME'),
                    'GITLABTOKEN': os.getenv('GITLABTOKEN'),
                    'GITLAB_USER_ID': os.getenv('GITLAB_USER_ID'),
                    'GITLAB_REPO_ID': os.getenv('GITLAB_REPO_ID'),
                    'SLACKMETABASETOKEN': os.getenv('SLACKMETABASETOKEN'),
                    'MB_URL': os.getenv('MB_URL'),
                    'MB_LOGIN_USERNAME': os.getenv('MB_LOGIN_USERNAME'),
                    'MB_LOGIN_PASSWORD': os.getenv('MB_LOGIN_PASSWORD'),
                    'MB_SLACK_CHANNEL': os.getenv('MB_SLACK_CHANNEL'),
                }
            }
        )

        # Repeat the step to GET all the Metabase Query Content
        search_tags_response = requests.get(
            f'{mb_url}/api/card/',
            headers=mb_headers,
        )


    mb_queries = json.loads(search_tags_response.text)

    # Get the saved queries from DynamoDB
    results = table.scan()
    tracked_queries = []
    tracked_names = []
    for item in results['Items']:
        tracked_queries.append(item['query_id'])
        tracked_names.append(item['filename'])

    # If any query has the <<VERSION CONTROL>> tag, but we do not track it in DynamoDB yet, add to DynamoDB
    for query in mb_queries:
        # Return the native query text of the metabase query
        if 'native' in query['dataset_query']:
            mb_query_content = query['dataset_query']['native']['query']
            if '<<VERSION CONTROL>>' in mb_query_content:
                if query['id'] not in tracked_queries:
                    raw_name = ''.join(
                        char for char in str(query['name']) if (char.isdigit() or char.isalpha() or char == ' ')
                    )
                    query_name = raw_name.replace(' ', '_').lower() + str(query['id']) + '.sql'
                    table.put_item(
                        Item={'query_id': int(query['id']), 'filename': str(query_name)}
                    )

    # Make sure there is time for the table to update
    time.sleep(15)

    # Scan again in case there was an update
    results = table.scan()

    # Iterate through the list of tracked queries in DynamoDB
    for item in results['Items']:

        query_id = item['query_id']
        query_filename = item['filename']

        # GET the Metabase query
        mb_response = requests.get(
            f'{mb_url}/api/card/{query_id}',
            headers=mb_headers
        )

        # Return the native query text of the metabase query
        mb_dict = json.loads(mb_response.text)
        mb_query_content = mb_dict['dataset_query']['native']['query']
        mb_query_name = mb_dict['name']
        mb_database = mb_dict['dataset_query']['database']
        actor_id = mb_dict['last-edit-info']['id']

        existing_branch = ''
        branch_query_content = ''
        valid_branch = False

        # Check if there is a valid open branch in Gitlab
        if 'branch' in item:
            existing_branch = item['branch']
            branch_query_response = requests.get(
                f'https://gitlab.com/api/v4/projects/{gitlab_repo_id}/repository/files/mb%2Fqueries%2F{query_filename}?ref={existing_branch}',
                headers=gitlab_headers
            )
            branch_query_content = ''
            # Check to make sure the branch from DynamoDB still exists
            if 'content' in json.loads(branch_query_response.text):
                valid_branch = True
                branch_query_dict = json.loads(branch_query_response.text)
                if 'file_name' in branch_query_dict:
                    branch_query_content = base64.b64decode(branch_query_dict['content']).decode('utf-8')
            # Clear the branch data in DynamoDB if the branch no longer exists
            else:
                remove_dynamodb_item(query_id, 'revert_at' in item)

        # Get the stored iid of the PR
        existing_iid = 0
        if 'iid' in item:
            existing_iid = item['iid']

        # Get the stored revert_at or use an arbitrarily large unixtime
        revert_at = 99999999999
        if 'revert_at' in item:
            revert_at = item['revert_at']

        # GET the saved query in the repo on main; assumes a path `mb/queries` in your repo
        query_response = requests.get(
            f'https://gitlab.com/api/v4/projects/{gitlab_repo_id}/repository/files/mb%2Fqueries%2F{query_filename}?ref=main',
            headers=gitlab_headers
        )

        # Return the query content from the repo
        query_dict = json.loads(query_response.text)

        main_query_content = ''

        # Get the file name if the query already exists in main
        if 'file_name' in query_dict:
            main_query_content = base64.b64decode(query_dict['content']).decode('utf-8')

        # Cases 1, 2, and 3 are when there is no open PR for the query
        if not valid_branch:

            # Case 1: No open PR and no .sql file on the main branch
            if 'file_name' not in query_dict:

                # Create a new PR to add the Metabase query to the repo as a new file
                branch, iid = new_branch(query_id, query_filename, mb_query_content, 'create', actor_id, mb_query_name)

                # Update DynamoDB
                update_dynamodb_item(branch, iid, query_id)

                continue

            # Case 2: No open PR and the .sql file on the main branch does not match the current Metabase query
            elif mb_query_content != main_query_content:

                # Create a new PR to update the file
                branch, iid = new_branch(query_id, query_filename, mb_query_content, 'update', actor_id, mb_query_name)
                revert_at = int(time.time()) + 3600 * 24 * 7 - 3600

                # Add branch, iid, and revert_at from DynamoDB
                update_dynamodb_item(branch, iid, query_id, revert_at)

                continue

            # Case 3: No open PR and the .sql file on the main branch matches the current Metabase query
            else:
                # Do nothing
                continue

        # Cases 4, 5, 6, and 7 are when there is an open PR and there is already a .sql file for the query on main
        elif 'file_name' in query_dict:

            # Case 4: There is an open PR, but the current query on Metabase matches the .sql file on main
            if mb_query_content == main_query_content:

                if 'iid' in item:

                    # Close PR
                    close_pr(existing_iid)

                # Remove branch and revert_at from DynamoDB
                remove_dynamodb_item(query_id, 'revert_at' in item)

                continue

            # Case 5: The PR has been open for more than a week
            elif int(time.time()) > revert_at:

                # Revert the metabase query to the version on the main branch
                json_query_update = {
                    "dataset_query": {
                        "type": "native",
                        "native": {
                            "query": main_query_content,
                            "template-tags": {}
                        },
                        "database": mb_database
                    }
                }
                mb_update_response = requests.put(
                    f'{mb_url}/api/card/{query_id}',
                    headers=gitlab_headers,
                    json=json_query_update
                )

                if 'iid' in item:

                    # Close PR
                    close_pr(existing_iid)

                # Remove branch, iid, and revert_at from DynamoDB
                remove_dynamodb_item(query_id, True)

                continue

            # Case 6: The open PR matches neither the .sql file on the main branch nor the new branch
            elif mb_query_content != branch_query_content:

                # Update the PR to reflect the new query in Metabase
                branch = update_branch(query_filename, mb_query_content, 'update', existing_branch)
                continue

            # Case 7: The current Metabase query matches the .sql file in the open PR
            else:
                # Do nothing
                continue

        # Cases 8 and 9 are when there is an open PR and the .sql file does not yet exist on main
        else:

            # Case 8: The current Metabase query is not on main and does not match the .sql file in the new branch
            if mb_query_content != branch_query_content:

                # Update the PR to reflect the new query in Metabase
                branch = update_branch(query_filename, mb_query_content, 'update', existing_branch)
                continue

            # Case 9: The current Metabase query is not on main and it matches the .sql file in the new branch
            else:
                # Do nothing
                continue
              
